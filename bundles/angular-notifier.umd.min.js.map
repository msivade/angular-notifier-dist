{"version":3,"sources":["../../../projects/angular-notifier/src/lib/models/notifier-notification.model.ts","../../../projects/angular-notifier/src/lib/services/notifier-queue.service.ts","../../../projects/angular-notifier/src/lib/notifier.tokens.ts","../../../projects/angular-notifier/src/lib/models/notifier-config.model.ts","../../../projects/angular-notifier/src/lib/services/notifier.service.ts","../../../projects/angular-notifier/src/lib/services/notifier-timer.service.ts","../../../projects/angular-notifier/src/lib/animation-presets/fade.animation-preset.ts","../../../projects/angular-notifier/src/lib/animation-presets/slide.animation-preset.ts","../../../projects/angular-notifier/src/lib/services/notifier-animation.service.ts","../../../projects/angular-notifier/src/lib/components/notifier-notification.component.html","../../../projects/angular-notifier/src/lib/components/notifier-notification.component.ts","../../../projects/angular-notifier/src/lib/components/notifier-container.component.html","../../../projects/angular-notifier/src/lib/components/notifier-container.component.ts","../../../projects/angular-notifier/src/lib/notifier.module.ts"],"names":["NotifierNotification","options","this","template","Object","assign","undefined","id","Date","getTime","NotifierQueueService","actionStream","Subject","actionQueue","isActionInProgress","prototype","push","action","tryToRunNextAction","continue","length","next","shift","factory","ɵfac","NotifierOptionsToken","InjectionToken","NotifierConfigToken","customOptions","animations","enabled","hide","easing","offset","preset","speed","overlap","show","behaviour","autoHide","onClick","onMouseover","showDismissButton","stacking","position","horizontal","distance","vertical","gap","theme","NotifierService","notifierQueueService","config","queueService","getConfig","notificationOptions","payload","type","notificationId","hideNewest","hideOldest","hideAll","notify","message","i0","ɵɵinject","NotifierTimerService","now","remaining","start","duration","_this","Promise","resolve","reject","finishPromiseResolver","pause","clearTimeout","timerId","window","setTimeout","finish","stop","fade","from","opacity","to","slide","notification","component","getShift","transform","NotifierAnimationService","animationPresets","getAnimationData","direction","keyframes","fill","i0.ɵɵelementContainer","i0.ɵɵproperty","ɵɵpureFunction1","_c0","ctx_r0","i0.ɵɵelementStart","i0.ɵɵlistener","i0.ɵɵnamespaceSVG","i0.ɵɵelement","i0.ɵɵelementEnd","i0.ɵɵtext","i0.ɵɵtemplate","i0.ɵɵadvance","i0.ɵɵtextInterpolate","NotifierNotificationComponent","elementRef","renderer","notifierService","notifierTimerService","notifierAnimationService","ready","EventEmitter","dismiss","timerService","animationService","element","nativeElement","elementShift","ngAfterViewInit","setup","elementHeight","offsetHeight","elementWidth","offsetWidth","emit","getHeight","getWidth","animationData","animatedProperties","keys","i","setStyle","animate","onfinish","startAutoHideTimer","stopAutoHideTimer","shiftToMakePlace","newElementShift","horizontalPosition","onClickDismiss","onNotificationMouseover","pauseAutoHideTimer","onNotificationMouseout","continueAutoHideTimer","onNotificationClick","then","addClass","$event","ɵɵrestoreView","_r3_1","ɵɵnextContext","onNotificationDismiss","ɵɵdirectiveInject","ElementRef","Renderer2","selectors","hostAttrs","hostBindings","rf","ctx","decls","vars","consts","_r1","NotifierContainerComponent","changeDetector","notifications","queueServiceSubscription","subscribe","handleAction","ngOnDestroy","unsubscribe","identifyNotification","index","onNotificationReady","notificationComponent","currentNotification","continueHandleShowAction","handleShowAction","handleHideAction","handleHideOldestAction","handleHideNewestAction","handleHideAllAction","tempPromiseResolver","addNotificationToList","numberOfNotifications","removeNotificationFromList","stepPromises_1","oldNotifications_1","slice","shiftNotifications","oldNotifications_2","all","stepPromises","findNotificationById","notificationIndex","findNotificationIndexById","oldNotifications","animationOffset","removeAllNotificationsFromList","toMakePlace","notificationPromises","markForCheck","filter","item","find","findIndex","notifierCustomConfigFactory","NotifierConfig","notifierDefaultConfigFactory","ChangeDetectorRef","NotifierModule","withConfig","ngModule","providers","provide","useValue","deps","useFactory","imports","CommonModule","declarations","exports"],"mappings":"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","sourcesContent":["import { NotifierNotificationComponent } from '../components/notifier-notification.component';\nimport { TemplateRef } from '@angular/core';\n\n/**\n * Notification\n *\n * This class describes the structure of a notifiction, including all information it needs to live, and everyone else needs to work with it.\n */\nexport class NotifierNotification {\n\t/**\n\t * Unique notification ID, can be set manually to control the notification from outside later on\n\t */\n\tpublic id: string;\n\n\t/**\n\t * Notification type, will be used for constructing an appropriate class name\n\t */\n\tpublic type: string;\n\n\t/**\n\t * Notification message\n\t */\n\tpublic message: string;\n\n\t/**\n\t * The template to customize\n\t * the appearance of the notification\n\t */\n\tpublic template?: TemplateRef<any> = null;\n\n\t/**\n\t * Component reference of this notification, created and set during creation time\n\t */\n\tpublic component: NotifierNotificationComponent;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param options Notifier options\n\t */\n\tpublic constructor(options: NotifierNotificationOptions) {\n\t\tObject.assign(this, options);\n\n\t\t// If not set manually, we have to create a unique notification ID by ourselves. The ID generation relies on the current browser\n\t\t// datetime in ms, in praticular the moment this notification gets constructed. Concurrency, and thus two IDs being the exact same,\n\t\t// is not possible due to the action queue concept.\n\t\tif (options.id === undefined) {\n\t\t\tthis.id = `ID_${new Date().getTime()}`;\n\t\t}\n\t}\n}\n\n/**\n * Notifiction options\n *\n * This interface describes which information are needed to create a new notification, or in other words, which information the external API\n * call must provide.\n */\nexport interface NotifierNotificationOptions {\n\t/**\n\t * Notification ID, optional\n\t */\n\tid?: string;\n\n\t/**\n\t * Notification type\n\t */\n\ttype: string;\n\n\t/**\n\t * Notificatin message\n\t */\n\tmessage: string;\n\n\t/**\n\t * The template to customize\n\t * the appearance of the notification\n\t */\n\ttemplate?: TemplateRef<any>;\n}\n","import { Injectable } from '@angular/core';\n\nimport { Subject } from 'rxjs';\n\nimport { NotifierAction } from '../models/notifier-action.model';\n\n/**\n * Notifier queue service\n *\n * In general, API calls don't get processed right away. Instead, we have to queue them up in order to prevent simultanious API calls\n * interfering with each other. This, at least in theory, is possible at any time. In particular, animations - which potentially overlap -\n * can cause changes in JS classes as well as affect the DOM. Therefore, the queue service takes all actions, puts them in a queue, and\n * processes them at the right time (which is when the previous action has been processed successfully).\n *\n * Technical sidenote:\n * An action looks pretty similar to the ones within the Flux / Redux pattern.\n */\n@Injectable()\nexport class NotifierQueueService {\n\n\t/**\n\t * Stream of actions, subscribable from outside\n\t */\n\tpublic readonly actionStream: Subject<NotifierAction>;\n\n\t/**\n\t * Queue of actions\n\t */\n\tprivate actionQueue: Array<NotifierAction>;\n\n\t/**\n\t * Flag, true if some action is currently in progress\n\t */\n\tprivate isActionInProgress: boolean;\n\n\t/**\n\t * Constructor\n\t */\n\tpublic constructor() {\n\t\tthis.actionStream = new Subject<NotifierAction>();\n\t\tthis.actionQueue = [];\n\t\tthis.isActionInProgress = false;\n\t}\n\n\t/**\n\t * Push a new action to the queue, and try to run it\n\t *\n\t * @param action Action object\n\t */\n\tpublic push( action: NotifierAction ): void {\n\t\tthis.actionQueue.push( action );\n\t\tthis.tryToRunNextAction();\n\t}\n\n\t/**\n\t * Continue with the next action (called when the current action is finished)\n\t */\n\tpublic continue(): void {\n\t\tthis.isActionInProgress = false;\n\t\tthis.tryToRunNextAction();\n\t}\n\n\t/**\n\t * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left\n\t */\n\tprivate tryToRunNextAction(): void {\n\t\tif ( this.isActionInProgress || this.actionQueue.length === 0 ) {\n\t\t\treturn; // Skip (the queue can now go drink a coffee as it has nothing to do anymore)\n\t\t}\n\t\tthis.isActionInProgress = true;\n\t\tthis.actionStream.next( this.actionQueue.shift() ); // Push next action to the stream, and remove the current action from the queue\n\t}\n\n}\n","import { NotifierConfig, NotifierOptions } from './models/notifier-config.model';\nimport { InjectionToken } from '@angular/core';\n\n// tslint:disable variable-name\n\n/**\n * Injection Token for notifier options\n */\nexport const NotifierOptionsToken: InjectionToken<NotifierOptions>\n\t= new InjectionToken<NotifierOptions>( '[angular-notifier] Notifier Options' );\n\n/**\n * Injection Token for notifier configuration\n */\nexport const NotifierConfigToken: InjectionToken<NotifierConfig>\n\t= new InjectionToken<NotifierConfig>( '[anuglar-notifier] Notifier Config' );\n\n// tslint:enable variable-name\n\n","/**\n * Notifier options\n */\nexport interface NotifierOptions {\n\tanimations?: {\n\t\tenabled?: boolean;\n\t\thide?: {\n\t\t\teasing?: string;\n\t\t\toffset?: number | false;\n\t\t\tpreset?: string;\n\t\t\tspeed?: number;\n\t\t};\n\t\toverlap?: number | false;\n\t\tshift?: {\n\t\t\teasing?: string;\n\t\t\tspeed?: number;\n\t\t};\n\t\tshow?: {\n\t\t\teasing?: string;\n\t\t\tpreset?: string;\n\t\t\tspeed?: number;\n\t\t};\n\t};\n\tbehaviour?: {\n\t\tautoHide?: number | false;\n\t\tonClick?: 'hide' | false;\n\t\tonMouseover?: 'pauseAutoHide' | 'resetAutoHide' | false;\n\t\tshowDismissButton?: boolean;\n\t\tstacking?: number | false;\n\t};\n\tposition?: {\n\t\thorizontal?: {\n\t\t\tdistance?: number;\n\t\t\tposition?: 'left' | 'middle' | 'right';\n\t\t};\n\t\tvertical?: {\n\t\t\tdistance?: number;\n\t\t\tgap?: number;\n\t\t\tposition?: 'top' | 'bottom';\n\t\t};\n\t};\n\ttheme?: string;\n}\n\n/**\n * Notifier configuration\n *\n * The notifier configuration defines what notifications look like, how they behave, and how they get animated. It is a global\n * configuration, which means that it only can be set once (at the beginning), and cannot be changed afterwards. Aligning to the world of\n * Angular, this configuration can be provided in the root app module - alternatively, a meaningful default configuration will be used.\n */\nexport class NotifierConfig implements NotifierOptions {\n\n\t/**\n\t * Customize animations\n\t */\n\tpublic animations: {\n\t\tenabled: boolean;\n\t\thide: {\n\t\t\teasing: string;\n\t\t\toffset: number | false;\n\t\t\tpreset: string;\n\t\t\tspeed: number;\n\t\t};\n\t\toverlap: number | false;\n\t\tshift: {\n\t\t\teasing: string;\n\t\t\tspeed: number;\n\t\t};\n\t\tshow: {\n\t\t\teasing: string;\n\t\t\tpreset: string;\n\t\t\tspeed: number;\n\t\t};\n\t};\n\n\t/**\n\t * Customize behaviour\n\t */\n\tpublic behaviour: {\n\t\tautoHide: number | false;\n\t\tonClick: 'hide' | false;\n\t\tonMouseover: 'pauseAutoHide' | 'resetAutoHide' | false;\n\t\tshowDismissButton: boolean;\n\t\tstacking: number | false;\n\t};\n\n\t/**\n\t * Customize positioning\n\t */\n\tpublic position: {\n\t\thorizontal: {\n\t\t\tdistance: number;\n\t\t\tposition: 'left' | 'middle' | 'right';\n\t\t};\n\t\tvertical: {\n\t\t\tdistance: number;\n\t\t\tgap: number;\n\t\t\tposition: 'top' | 'bottom';\n\t\t};\n\t};\n\n\t/**\n\t * Customize theming\n\t */\n\tpublic theme: string;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param [customOptions={}] Custom notifier options, optional\n\t */\n\tpublic constructor( customOptions: NotifierOptions = {} ) {\n\n\t\t// Set default values\n\t\tthis.animations = {\n\t\t\tenabled: true,\n\t\t\thide: {\n\t\t\t\teasing: 'ease',\n\t\t\t\toffset: 50,\n\t\t\t\tpreset: 'fade',\n\t\t\t\tspeed: 300\n\t\t\t},\n\t\t\toverlap: 150,\n\t\t\tshift: {\n\t\t\t\teasing: 'ease',\n\t\t\t\tspeed: 300\n\t\t\t},\n\t\t\tshow: {\n\t\t\t\teasing: 'ease',\n\t\t\t\tpreset: 'slide',\n\t\t\t\tspeed: 300\n\t\t\t}\n\t\t};\n\t\tthis.behaviour = {\n\t\t\tautoHide: 7000,\n\t\t\tonClick: false,\n\t\t\tonMouseover: 'pauseAutoHide',\n\t\t\tshowDismissButton: true,\n\t\t\tstacking: 4\n\t\t};\n\t\tthis.position = {\n\t\t\thorizontal: {\n\t\t\t\tdistance: 12,\n\t\t\t\tposition: 'left'\n\t\t\t},\n\t\t\tvertical: {\n\t\t\t\tdistance: 12,\n\t\t\t\tgap: 10,\n\t\t\t\tposition: 'bottom'\n\t\t\t}\n\t\t};\n\t\tthis.theme = 'material';\n\n\t\t// The following merges the custom options into the notifier config, respecting the already set default values\n\t\t// This linear, more explicit and code-sizy workflow is preferred here over a recursive one (because we know the object structure)\n\t\t// Technical sidenote: Objects are merged, other types of values simply overwritten / copied\n\t\tif ( customOptions.theme !== undefined ) {\n\t\t\tthis.theme = customOptions.theme;\n\t\t}\n\t\tif ( customOptions.animations !== undefined ) {\n\t\t\tif ( customOptions.animations.enabled !== undefined ) {\n\t\t\t\tthis.animations.enabled = customOptions.animations.enabled;\n\t\t\t}\n\t\t\tif ( customOptions.animations.overlap !== undefined ) {\n\t\t\t\tthis.animations.overlap = customOptions.animations.overlap;\n\t\t\t}\n\t\t\tif ( customOptions.animations.hide !== undefined ) {\n\t\t\t\tObject.assign( this.animations.hide, customOptions.animations.hide );\n\t\t\t}\n\t\t\tif ( customOptions.animations.shift !== undefined ) {\n\t\t\t\tObject.assign( this.animations.shift, customOptions.animations.shift );\n\t\t\t}\n\t\t\tif ( customOptions.animations.show !== undefined ) {\n\t\t\t\tObject.assign( this.animations.show, customOptions.animations.show );\n\t\t\t}\n\t\t}\n\t\tif ( customOptions.behaviour !== undefined ) {\n\t\t\tObject.assign( this.behaviour, customOptions.behaviour );\n\t\t}\n\t\tif ( customOptions.position !== undefined ) {\n\t\t\tif ( customOptions.position.horizontal !== undefined ) {\n\t\t\t\tObject.assign( this.position.horizontal, customOptions.position.horizontal );\n\t\t\t}\n\t\t\tif ( customOptions.position.vertical !== undefined ) {\n\t\t\t\tObject.assign( this.position.vertical, customOptions.position.vertical );\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n","import { Inject, Injectable, forwardRef } from '@angular/core';\n\nimport { NotifierConfig } from '../models/notifier-config.model';\nimport { NotifierNotificationOptions } from '../models/notifier-notification.model';\nimport { NotifierQueueService } from './notifier-queue.service';\nimport { NotifierConfigToken } from '../notifier.tokens';\n\n/**\n * Notifier service\n *\n * This service provides access to the public notifier API. Once injected into a component, directive, pipe, service, or any other building\n * block of an applications, it can be used to show new notifications, and hide existing ones. Internally, it transforms API calls into\n * actions, which then get thrown into the action queue - eventually being processed at the right moment.\n */\n@Injectable()\nexport class NotifierService {\n\n\t/**\n\t * Notifier queue service\n\t */\n\tprivate readonly queueService: NotifierQueueService;\n\n\t/**\n\t * Notifier configuration\n\t */\n\tprivate readonly config: NotifierConfig;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param notifierQueueService Notifier queue service\n\t * @param config               Notifier configuration, optionally injected as a dependency\n\t */\n\tpublic constructor(\n\t\tnotifierQueueService: NotifierQueueService,\n\t\t@Inject(NotifierConfigToken) config: NotifierConfig\n\t) {\n\t\tthis.queueService = notifierQueueService;\n\t\tthis.config = config;\n\t}\n\n\t/**\n\t * Get the notifier configuration\n\t *\n\t * @returns Notifier configuration\n\t */\n\tpublic getConfig(): NotifierConfig {\n\t\treturn this.config;\n\t}\n\n\t/**\n\t * API: Show a new notification\n\t *\n\t * @param notificationOptions Notification options\n\t */\n\tpublic show( notificationOptions: NotifierNotificationOptions ): void {\n\t\tthis.queueService.push( {\n\t\t\tpayload: notificationOptions,\n\t\t\ttype: 'SHOW'\n\t\t} );\n\t}\n\n\t/**\n\t * API: Hide a specific notification, given its ID\n\t *\n\t * @param notificationId ID of the notification to hide\n\t */\n\tpublic hide( notificationId: string ): void {\n\t\tthis.queueService.push( {\n\t\t\tpayload: notificationId,\n\t\t\ttype: 'HIDE'\n\t\t} );\n\t}\n\n\t/**\n\t * API: Hide the newest notification\n\t */\n\tpublic hideNewest(): void {\n\t\tthis.queueService.push( {\n\t\t\ttype: 'HIDE_NEWEST'\n\t\t} );\n\t}\n\n\t/**\n\t * API: Hide the oldest notification\n\t */\n\tpublic hideOldest(): void {\n\t\tthis.queueService.push( {\n\t\t\ttype: 'HIDE_OLDEST'\n\t\t} );\n\t}\n\n\t/**\n\t * API: Hide all notifications at once\n\t */\n\tpublic hideAll(): void {\n\t\tthis.queueService.push( {\n\t\t\ttype: 'HIDE_ALL'\n\t\t} );\n\t}\n\n\t/**\n\t * API: Shortcut for showing a new notification\n\t *\n\t * @param type             Type of the notification\n\t * @param message          Message of the notification\n\t * @param [notificationId] Unique ID for the notification (optional)\n\t */\n\tpublic notify( type: string, message: string, notificationId?: string ): void {\n\t\tlet notificationOptions: NotifierNotificationOptions = {\n\t\t\tmessage,\n\t\t\ttype\n\t\t};\n\t\tif ( notificationId !== undefined ) {\n\t\t\tnotificationOptions.id = notificationId;\n\t\t}\n\t\tthis.show( notificationOptions );\n\t}\n\n}\n","import { Injectable } from '@angular/core';\n\n/**\n * Notifier timer service\n *\n * This service acts as a timer, needed due to the still rather limited setTimeout JavaScript API. The timer service can start and stop a\n * timer. Furthermore, it can also pause the timer at any time, and resume later on. The timer API workd promise-based.\n */\n@Injectable()\nexport class NotifierTimerService {\n\n\t/**\n\t * Timestamp (in ms), created in the moment the timer starts\n\t */\n\tprivate now: number;\n\n\t/**\n\t * Remaining time (in ms)\n\t */\n\tprivate remaining: number;\n\n\t/**\n\t * Timeout ID, used for clearing the timeout later on\n\t */\n\tprivate timerId: number;\n\n\t/**\n\t * Promise resolve function, eventually getting called once the timer finishes\n\t */\n\tprivate finishPromiseResolver: () => void;\n\n\t/**\n\t * Constructor\n\t */\n\tpublic constructor() {\n\t\tthis.now = 0;\n\t\tthis.remaining = 0;\n\t}\n\n\t/**\n\t * Start (or resume) the timer\n\t *\n\t * @param   duration Timer duration, in ms\n\t * @returns          Promise, resolved once the timer finishes\n\t */\n\tpublic start( duration: number ): Promise<undefined> {\n\t\treturn new Promise<undefined>( ( resolve: () => void, reject: () => void ) => {\n\n\t\t\t// For the first run ...\n\t\t\tthis.remaining = duration;\n\n\t\t\t// Setup, then start the timer\n\t\t\tthis.finishPromiseResolver = resolve;\n\t\t\tthis.continue();\n\n\t\t} );\n\t}\n\n\t/**\n\t * Pause the timer\n\t */\n\tpublic pause(): void {\n\t\tclearTimeout( this.timerId );\n\t\tthis.remaining -= new Date().getTime() - this.now;\n\t}\n\n\t/**\n\t * Continue the timer\n\t */\n\tpublic continue(): void {\n\t\tthis.now = new Date().getTime();\n\t\tthis.timerId = window.setTimeout( () => {\n\t\t\tthis.finish();\n\t\t}, this.remaining );\n\t}\n\n\t/**\n\t * Stop the timer\n\t */\n\tpublic stop(): void {\n\t\tclearTimeout( this.timerId );\n\t\tthis.remaining = 0;\n\t}\n\n\t/**\n\t * Finish up the timeout by resolving the timer promise\n\t */\n\tprivate finish(): void {\n\t\tthis.finishPromiseResolver();\n\t}\n\n}\n","import { NotifierAnimationPreset, NotifierAnimationPresetKeyframes } from '../models/notifier-animation.model';\n\n/**\n * Fade animation preset\n */\nexport const fade: NotifierAnimationPreset = {\n\thide: (): NotifierAnimationPresetKeyframes => {\n\t\treturn {\n\t\t\tfrom: {\n\t\t\t\topacity: '1'\n\t\t\t},\n\t\t\tto: {\n\t\t\t\topacity: '0'\n\t\t\t}\n\t\t};\n\t},\n\tshow: (): NotifierAnimationPresetKeyframes => {\n\t\treturn {\n\t\t\tfrom: {\n\t\t\t\topacity: '0'\n\t\t\t},\n\t\t\tto: {\n\t\t\t\topacity: '1'\n\t\t\t}\n\t\t};\n\t}\n};\n","import { NotifierAnimationPreset, NotifierAnimationPresetKeyframes } from '../models/notifier-animation.model';\nimport { NotifierConfig } from '../models/notifier-config.model';\nimport { NotifierNotification } from '../models/notifier-notification.model';\n\n/**\n * Slide animation preset\n */\nexport const slide: NotifierAnimationPreset = {\n\thide: ( notification: NotifierNotification ): NotifierAnimationPresetKeyframes => {\n\n\t\t// Prepare variables\n\t\tconst config: NotifierConfig = notification.component.getConfig();\n\t\tconst shift: number = notification.component.getShift();\n\t\tlet from: {\n\t\t\t[ animatablePropertyName: string ]: string;\n\t\t};\n\t\tlet to: {\n\t\t\t[ animatablePropertyName: string ]: string;\n\t\t};\n\n\t\t// Configure variables, depending on configuration and component\n\t\tif ( config.position.horizontal.position === 'left' ) {\n\t\t\tfrom = {\n\t\t\t\ttransform: `translate3d( 0, ${ shift }px, 0 )`\n\t\t\t};\n\t\t\tto = {\n\t\t\t\ttransform: `translate3d( calc( -100% - ${ config.position.horizontal.distance }px - 10px ), ${ shift }px, 0 )`\n\t\t\t};\n\t\t} else if ( config.position.horizontal.position === 'right' ) {\n\t\t\tfrom = {\n\t\t\t\ttransform: `translate3d( 0, ${ shift }px, 0 )`\n\t\t\t};\n\t\t\tto = {\n\t\t\t\ttransform: `translate3d( calc( 100% + ${ config.position.horizontal.distance }px + 10px ), ${ shift }px, 0 )`\n\t\t\t};\n\t\t} else {\n\t\t\tlet horizontalPosition: string;\n\t\t\tif ( config.position.vertical.position === 'top' ) {\n\t\t\t\thorizontalPosition = `calc( -100% - ${ config.position.horizontal.distance }px - 10px )`;\n\t\t\t} else {\n\t\t\t\thorizontalPosition = `calc( 100% + ${ config.position.horizontal.distance }px + 10px )`;\n\t\t\t}\n\t\t\tfrom = {\n\t\t\t\ttransform: `translate3d( -50%, ${ shift }px, 0 )`\n\t\t\t};\n\t\t\tto = {\n\t\t\t\ttransform: `translate3d( -50%, ${ horizontalPosition }, 0 )`\n\t\t\t};\n\t\t}\n\n\t\t// Done\n\t\treturn {\n\t\t\tfrom,\n\t\t\tto\n\t\t};\n\n\t},\n\tshow: ( notification: NotifierNotification ): NotifierAnimationPresetKeyframes => {\n\n\t\t// Prepare variables\n\t\tconst config: NotifierConfig = notification.component.getConfig();\n\t\tlet from: {\n\t\t\t[ animatablePropertyName: string ]: string;\n\t\t};\n\t\tlet to: {\n\t\t\t[ animatablePropertyName: string ]: string;\n\t\t};\n\n\t\t// Configure variables, depending on configuration and component\n\t\tif ( config.position.horizontal.position === 'left' ) {\n\t\t\tfrom = {\n\t\t\t\ttransform: `translate3d( calc( -100% - ${ config.position.horizontal.distance }px - 10px ), 0, 0 )`\n\t\t\t};\n\t\t\tto = {\n\t\t\t\ttransform: 'translate3d( 0, 0, 0 )'\n\t\t\t};\n\t\t} else if ( config.position.horizontal.position === 'right' ) {\n\t\t\tfrom = {\n\t\t\t\ttransform: `translate3d( calc( 100% + ${ config.position.horizontal.distance }px + 10px ), 0, 0 )`\n\t\t\t};\n\t\t\tto = {\n\t\t\t\ttransform: 'translate3d( 0, 0, 0 )'\n\t\t\t};\n\t\t} else {\n\t\t\tlet horizontalPosition: string;\n\t\t\tif ( config.position.vertical.position === 'top' ) {\n\t\t\t\thorizontalPosition = `calc( -100% - ${ config.position.horizontal.distance }px - 10px )`;\n\t\t\t} else {\n\t\t\t\thorizontalPosition = `calc( 100% + ${ config.position.horizontal.distance }px + 10px )`;\n\t\t\t}\n\t\t\tfrom = {\n\t\t\t\ttransform: `translate3d( -50%, ${ horizontalPosition }, 0 )`\n\t\t\t};\n\t\t\tto = {\n\t\t\t\ttransform: 'translate3d( -50%, 0, 0 )'\n\t\t\t};\n\t\t}\n\n\t\t// Done\n\t\treturn {\n\t\t\tfrom,\n\t\t\tto\n\t\t};\n\n\t}\n};\n","import { Injectable } from '@angular/core';\n\nimport { NotifierAnimationData, NotifierAnimationPreset, NotifierAnimationPresetKeyframes } from '../models/notifier-animation.model';\nimport { NotifierNotification } from '../models/notifier-notification.model';\nimport { fade } from '../animation-presets/fade.animation-preset';\nimport { slide } from '../animation-presets/slide.animation-preset';\n\n/**\n * Notifier animation service\n */\n@Injectable()\nexport class NotifierAnimationService {\n\n\t/**\n\t * List of animation presets (currently static)\n\t */\n\tprivate readonly animationPresets: {\n\t\t[ animationPresetName: string ]: NotifierAnimationPreset\n\t};\n\n\t/**\n\t * Constructor\n\t */\n\tpublic constructor() {\n\t\tthis.animationPresets = {\n\t\t\tfade,\n\t\t\tslide\n\t\t};\n\t}\n\n\t/**\n\t * Get animation data\n\t *\n\t * This method generates all data the Web Animations API needs to animate our notification. The result depends on both the animation\n\t * direction (either in or out) as well as the notifications (and its attributes) itself.\n\t *\n\t * @param   direction    Animation direction, either in or out\n\t * @param   notification Notification the animation data should be generated for\n\t * @returns Animation information\n\t */\n\tpublic getAnimationData( direction: 'show' | 'hide', notification: NotifierNotification ): NotifierAnimationData {\n\n\t\t// Get all necessary animation data\n\t\tlet keyframes: NotifierAnimationPresetKeyframes;\n\t\tlet duration: number;\n\t\tlet easing: string;\n\t\tif ( direction === 'show' ) {\n\t\t\tkeyframes = this.animationPresets[ notification.component.getConfig().animations.show.preset ].show( notification );\n\t\t\tduration = notification.component.getConfig().animations.show.speed;\n\t\t\teasing = notification.component.getConfig().animations.show.easing;\n\t\t} else {\n\t\t\tkeyframes = this.animationPresets[ notification.component.getConfig().animations.hide.preset ].hide( notification );\n\t\t\tduration = notification.component.getConfig().animations.hide.speed;\n\t\t\teasing = notification.component.getConfig().animations.hide.easing;\n\t\t}\n\n\t\t// Build and return animation data\n\t\treturn {\n\t\t\tkeyframes: [\n\t\t\t\tkeyframes.from,\n\t\t\t\tkeyframes.to\n\t\t\t],\n\t\t\toptions: {\n\t\t\t\tduration,\n\t\t\t\teasing,\n\t\t\t\tfill: 'forwards' // Keep the newly painted state after the animation finished\n\t\t\t}\n\t\t};\n\n\t}\n\n}\n","<ng-container *ngIf=\"notification.template; else predefinedNotification\" [ngTemplateOutlet]=\"notification.template\" [ngTemplateOutletContext]=\"{ notification: notification }\">\n</ng-container>\n\n<ng-template #predefinedNotification>\n\t<p class=\"notifier__notification-message\">{{ notification.message }}</p>\n\t<button class=\"notifier__notification-button\" type=\"button\" title=\"dismiss\" *ngIf=\"config.behaviour.showDismissButton\" (click)=\"onClickDismiss()\">\n\t\t<svg class=\"notifier__notification-button-icon\" viewBox=\"0 0 24 24\" width=\"20\" height=\"20\">\n\t\t\t<path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" />\n\t\t</svg>\n\t</button>\n</ng-template>\n","import { AfterViewInit, ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, Renderer2 } from '@angular/core';\n\nimport { NotifierAnimationData } from '../models/notifier-animation.model';\nimport { NotifierAnimationService } from '../services/notifier-animation.service';\nimport { NotifierConfig } from '../models/notifier-config.model';\nimport { NotifierNotification } from '../models/notifier-notification.model';\nimport { NotifierService } from '../services/notifier.service';\nimport { NotifierTimerService } from '../services/notifier-timer.service';\n\n/**\n * Notifier notification component\n * -------------------------------\n * This component is responsible for actually displaying the notification on screen. In addition, it's able to show and hide this\n * notification, in particular to animate this notification in and out, as well as shift (move) this notification vertically around.\n * Furthermore, the notification component handles all interactions the user has with this notification / component, such as clicks and\n * mouse movements.\n */\n@Component( {\n\tchangeDetection: ChangeDetectionStrategy.OnPush, // (#perfmatters)\n\thost: {\n\t\t'(click)': 'onNotificationClick()',\n\t\t'(mouseout)': 'onNotificationMouseout()',\n\t\t'(mouseover)': 'onNotificationMouseover()',\n\t\tclass: 'notifier__notification'\n\t},\n\tproviders: [\n\t\t// We provide the timer to the component's local injector, so that every notification components gets its own\n\t\t// instance of the timer service, thus running their timers independently from each other\n\t\tNotifierTimerService\n\t],\n\tselector: 'notifier-notification',\n\ttemplateUrl: './notifier-notification.component.html'\n} )\nexport class NotifierNotificationComponent implements AfterViewInit {\n\n\t/**\n\t * Input: Notification object, contains all details necessary to construct the notification\n\t */\n\t@Input()\n\tpublic notification: NotifierNotification;\n\n\t/**\n\t * Output: Ready event, handles the initialization success by emitting a reference to this notification component\n\t */\n\t@Output()\n\tpublic ready: EventEmitter<NotifierNotificationComponent>;\n\n\t/**\n\t * Output: Dismiss event, handles the click on the dismiss button by emitting the notification ID of this notification component\n\t */\n\t@Output()\n\tpublic dismiss: EventEmitter<string>;\n\n\t/**\n\t * Notifier configuration\n\t */\n\tpublic readonly config: NotifierConfig;\n\n\t/**\n\t * Notifier timer service\n\t */\n\tprivate readonly timerService: NotifierTimerService;\n\n\t/**\n\t * Notifier animation service\n\t */\n\tprivate readonly animationService: NotifierAnimationService;\n\n\t/**\n\t * Angular renderer, used to preserve the overall DOM abstraction & independence\n\t */\n\tprivate readonly renderer: Renderer2;\n\n\t/**\n\t * Native element reference, used for manipulating DOM properties\n\t */\n\tprivate readonly element: HTMLElement;\n\n\t/**\n\t * Current notification height, calculated and cached here (#perfmatters)\n\t */\n\tprivate elementHeight: number;\n\n\t/**\n\t * Current notification width, calculated and cached here (#perfmatters)\n\t */\n\tprivate elementWidth: number;\n\n\t/**\n\t * Current notification shift, calculated and cached here (#perfmatters)\n\t */\n\tprivate elementShift: number;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param elementRef               Reference to the component's element\n\t * @param renderer                 Angular renderer\n\t * @param notifierService          Notifier service\n\t * @param notifierTimerService     Notifier timer service\n\t * @param notifierAnimationService Notifier animation service\n\t */\n\tpublic constructor( elementRef: ElementRef, renderer: Renderer2, notifierService: NotifierService,\n\t\tnotifierTimerService: NotifierTimerService, notifierAnimationService: NotifierAnimationService ) {\n\t\tthis.config = notifierService.getConfig();\n\t\tthis.ready = new EventEmitter<NotifierNotificationComponent>();\n\t\tthis.dismiss = new EventEmitter<string>();\n\t\tthis.timerService = notifierTimerService;\n\t\tthis.animationService = notifierAnimationService;\n\t\tthis.renderer = renderer;\n\t\tthis.element = elementRef.nativeElement;\n\t\tthis.elementShift = 0;\n\t}\n\n\t/**\n\t * Component after view init lifecycle hook, setts up the component and then emits the ready event\n\t */\n\tpublic ngAfterViewInit(): void {\n\t\tthis.setup();\n\t\tthis.elementHeight = this.element.offsetHeight;\n\t\tthis.elementWidth = this.element.offsetWidth;\n\t\tthis.ready.emit( this );\n\t}\n\n\t/**\n\t * Get the notifier config\n\t *\n\t * @returns Notifier configuration\n\t */\n\tpublic getConfig(): NotifierConfig {\n\t\treturn this.config;\n\t}\n\n\t/**\n\t * Get notification element height (in px)\n\t *\n\t * @returns Notification element height (in px)\n\t */\n\tpublic getHeight(): number {\n\t\treturn this.elementHeight;\n\t}\n\n\t/**\n\t * Get notification element width (in px)\n\t *\n\t * @returns Notification element height (in px)\n\t */\n\tpublic getWidth(): number {\n\t\treturn this.elementWidth;\n\t}\n\n\t/**\n\t * Get notification shift offset (in px)\n\t *\n\t * @returns Notification element shift offset (in px)\n\t */\n\tpublic getShift(): number {\n\t\treturn this.elementShift;\n\t}\n\n\t/**\n\t * Show (animate in) this notification\n\t *\n\t * @returns Promise, resolved when done\n\t */\n\tpublic show(): Promise<undefined> {\n\t\treturn new Promise<undefined>( ( resolve: () => void, reject: () => void ) => {\n\n\t\t\t// Are animations enabled?\n\t\t\tif ( this.config.animations.enabled && this.config.animations.show.speed > 0 ) {\n\n\t\t\t\t// Get animation data\n\t\t\t\tconst animationData: NotifierAnimationData = this.animationService.getAnimationData( 'show', this.notification );\n\n\t\t\t\t// Set initial styles (styles before animation), prevents quick flicker when animation starts\n\t\t\t\tconst animatedProperties: Array<string> = Object.keys( animationData.keyframes[ 0 ] );\n\t\t\t\tfor ( let i: number = animatedProperties.length - 1; i >= 0; i-- ) {\n\t\t\t\t\tthis.renderer.setStyle( this.element, animatedProperties[ i ],\n\t\t\t\t\t\tanimationData.keyframes[ 0 ][ animatedProperties[ i ] ] );\n\t\t\t\t}\n\n\t\t\t\t// Animate notification in\n\t\t\t\tthis.renderer.setStyle( this.element, 'visibility', 'visible' );\n\t\t\t\tconst animation: Animation = this.element.animate( animationData.keyframes, animationData.options );\n\t\t\t\tanimation.onfinish = () => {\n\t\t\t\t\tthis.startAutoHideTimer();\n\t\t\t\t\tresolve(); // Done\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\t// Show notification\n\t\t\t\tthis.renderer.setStyle( this.element, 'visibility', 'visible' );\n\t\t\t\tthis.startAutoHideTimer();\n\t\t\t\tresolve(); // Done\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Hide (animate out) this notification\n\t *\n\t * @returns Promise, resolved when done\n\t */\n\tpublic hide(): Promise<undefined> {\n\t\treturn new Promise<undefined>( ( resolve: () => void, reject: () => void ) => {\n\n\t\t\tthis.stopAutoHideTimer();\n\n\t\t\t// Are animations enabled?\n\t\t\tif ( this.config.animations.enabled && this.config.animations.hide.speed > 0 ) {\n\t\t\t\tconst animationData: NotifierAnimationData = this.animationService.getAnimationData( 'hide', this.notification );\n\t\t\t\tconst animation: Animation = this.element.animate( animationData.keyframes, animationData.options );\n\t\t\t\tanimation.onfinish = () => {\n\t\t\t\t\tresolve(); // Done\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tresolve(); // Done\n\t\t\t}\n\n\t\t} );\n\t}\n\n\t/**\n\t * Shift (move) this notification\n\t *\n\t * @param   distance         Distance to shift (in px)\n\t * @param   shiftToMakePlace Flag, defining in which direction to shift\n\t * @returns Promise, resolved when done\n\t */\n\tpublic shift( distance: number, shiftToMakePlace: boolean ): Promise<undefined> {\n\t\treturn new Promise<undefined>( ( resolve: () => void, reject: () => void ) => {\n\n\t\t\t// Calculate new position (position after the shift)\n\t\t\tlet newElementShift: number;\n\t\t\tif ( ( this.config.position.vertical.position === 'top' && shiftToMakePlace )\n\t\t\t\t|| ( this.config.position.vertical.position === 'bottom' && !shiftToMakePlace ) ) {\n\t\t\t\tnewElementShift = this.elementShift + distance + this.config.position.vertical.gap;\n\t\t\t} else {\n\t\t\t\tnewElementShift = this.elementShift - distance - this.config.position.vertical.gap;\n\t\t\t}\n\t\t\tconst horizontalPosition: string = this.config.position.horizontal.position === 'middle' ? '-50%' : '0';\n\n\t\t\t// Are animations enabled?\n\t\t\tif ( this.config.animations.enabled && this.config.animations.shift.speed > 0 ) {\n\t\t\t\tconst animationData: NotifierAnimationData = { // TODO: Extract into animation service\n\t\t\t\t\tkeyframes: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttransform: `translate3d( ${ horizontalPosition }, ${ this.elementShift }px, 0 )`\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttransform: `translate3d( ${ horizontalPosition }, ${ newElementShift }px, 0 )`\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tduration: this.config.animations.shift.speed,\n\t\t\t\t\t\teasing: this.config.animations.shift.easing,\n\t\t\t\t\t\tfill: 'forwards'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.elementShift = newElementShift;\n\t\t\t\tconst animation: Animation = this.element.animate( animationData.keyframes, animationData.options );\n\t\t\t\tanimation.onfinish = () => {\n\t\t\t\t\tresolve(); // Done\n\t\t\t\t};\n\n\t\t\t} else {\n\t\t\t\tthis.renderer.setStyle( this.element, 'transform', `translate3d( ${ horizontalPosition }, ${ newElementShift }px, 0 )` );\n\t\t\t\tthis.elementShift = newElementShift;\n\t\t\t\tresolve(); // Done\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Handle click on dismiss button\n\t */\n\tpublic onClickDismiss(): void {\n\t\tthis.dismiss.emit( this.notification.id );\n\t}\n\n\t/**\n\t * Handle mouseover over notification area\n\t */\n\tpublic onNotificationMouseover(): void {\n\t\tif ( this.config.behaviour.onMouseover === 'pauseAutoHide' ) {\n\t\t\tthis.pauseAutoHideTimer();\n\t\t} else if ( this.config.behaviour.onMouseover === 'resetAutoHide' ) {\n\t\t\tthis.stopAutoHideTimer();\n\t\t}\n\t}\n\n\t/**\n\t * Handle mouseout from notification area\n\t */\n\tpublic onNotificationMouseout(): void {\n\t\tif ( this.config.behaviour.onMouseover === 'pauseAutoHide' ) {\n\t\t\tthis.continueAutoHideTimer();\n\t\t} else if ( this.config.behaviour.onMouseover === 'resetAutoHide' ) {\n\t\t\tthis.startAutoHideTimer();\n\t\t}\n\t}\n\n\t/**\n\t * Handle click on notification area\n\t */\n\tpublic onNotificationClick(): void {\n\t\tif ( this.config.behaviour.onClick === 'hide' ) {\n\t\t\tthis.onClickDismiss();\n\t\t}\n\t}\n\n\t/**\n\t * Start the auto hide timer (if enabled)\n\t */\n\tprivate startAutoHideTimer(): void {\n\t\tif ( this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0 ) {\n\t\t\tthis.timerService.start( this.config.behaviour.autoHide ).then( () => {\n\t\t\t\tthis.onClickDismiss();\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Pause the auto hide timer (if enabled)\n\t */\n\tprivate pauseAutoHideTimer(): void {\n\t\tif ( this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0 ) {\n\t\t\tthis.timerService.pause();\n\t\t}\n\t}\n\n\t/**\n\t * Continue the auto hide timer (if enabled)\n\t */\n\tprivate continueAutoHideTimer(): void {\n\t\tif ( this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0 ) {\n\t\t\tthis.timerService.continue();\n\t\t}\n\t}\n\n\t/**\n\t * Stop the auto hide timer (if enabled)\n\t */\n\tprivate stopAutoHideTimer(): void {\n\t\tif ( this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0 ) {\n\t\t\tthis.timerService.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Initial notification setup\n\t */\n\tprivate setup(): void {\n\n\t\t// Set start position (initially the exact same for every new notification)\n\t\tif ( this.config.position.horizontal.position === 'left' ) {\n\t\t\tthis.renderer.setStyle( this.element, 'left', `${ this.config.position.horizontal.distance }px` );\n\t\t} else if ( this.config.position.horizontal.position === 'right' ) {\n\t\t\tthis.renderer.setStyle( this.element, 'right', `${ this.config.position.horizontal.distance }px` );\n\t\t} else {\n\t\t\tthis.renderer.setStyle( this.element, 'left', '50%' );\n\t\t\t// Let's get the GPU handle some work as well (#perfmatters)\n\t\t\tthis.renderer.setStyle( this.element, 'transform', 'translate3d( -50%, 0, 0 )' );\n\t\t}\n\t\tif ( this.config.position.vertical.position === 'top' ) {\n\t\t\tthis.renderer.setStyle( this.element, 'top', `${ this.config.position.vertical.distance }px` );\n\t\t} else {\n\t\t\tthis.renderer.setStyle( this.element, 'bottom', `${ this.config.position.vertical.distance }px` );\n\t\t}\n\n\t\t// Add classes (responsible for visual design)\n\t\tthis.renderer.addClass( this.element, `notifier__notification--${ this.notification.type }` );\n\t\tthis.renderer.addClass( this.element, `notifier__notification--${ this.config.theme }` );\n\n\t}\n\n}\n","<ul>\n\t<li class=\"notifier__container-list\" *ngFor=\"let notification of notifications; trackBy: identifyNotification;\">\n\t\t<notifier-notification\n\t\t\t[notification]=\"notification\"\n\t\t\t(ready)=\"onNotificationReady( $event )\"\n\t\t\t(dismiss)=\"onNotificationDismiss( $event )\">\n\t\t</notifier-notification>\n\t</li>\n</ul>\n","import { ChangeDetectionStrategy, ChangeDetectorRef, Component, OnDestroy } from '@angular/core';\n\nimport { Subscription } from 'rxjs';\n\nimport { NotifierAction } from '../models/notifier-action.model';\nimport { NotifierConfig } from '../models/notifier-config.model';\nimport { NotifierNotification } from '../models/notifier-notification.model';\nimport { NotifierQueueService } from '../services/notifier-queue.service';\nimport { NotifierService } from '../services/notifier.service';\nimport { NotifierNotificationComponent } from './notifier-notification.component';\n\n/**\n * Notifier container component\n * ----------------------------\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\n * by subscribing to its action stream.\n *\n * Technical sidenote:\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\n */\n@Component( {\n\tchangeDetection: ChangeDetectionStrategy.OnPush, // (#perfmatters)\n\thost: {\n\t\tclass: 'notifier__container'\n\t},\n\tselector: 'notifier-container',\n\ttemplateUrl: './notifier-container.component.html'\n} )\nexport class NotifierContainerComponent implements OnDestroy {\n\n\t/**\n\t * List of currently somewhat active notifications\n\t */\n\tpublic notifications: Array<NotifierNotification>;\n\n\t/**\n\t * Change detector\n\t */\n\tprivate readonly changeDetector: ChangeDetectorRef;\n\n\t/**\n\t * Notifier queue service\n\t */\n\tprivate readonly queueService: NotifierQueueService;\n\n\t/**\n\t * Notifier configuration\n\t */\n\tprivate readonly config: NotifierConfig;\n\n\t/**\n\t * Queue service observable subscription (saved for cleanup)\n\t */\n\tprivate queueServiceSubscription: Subscription;\n\n\t/**\n\t * Promise resolve function reference, temporarily used while the notification child component gets created\n\t */\n\tprivate tempPromiseResolver: () => void;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param changeDetector       Change detector, used for manually triggering change detection runs\n\t * @param notifierQueueService Notifier queue service\n\t * @param notifierService      Notifier service\n\t */\n\tpublic constructor( changeDetector: ChangeDetectorRef, notifierQueueService: NotifierQueueService, notifierService: NotifierService ) {\n\t\tthis.changeDetector = changeDetector;\n\t\tthis.queueService = notifierQueueService;\n\t\tthis.config = notifierService.getConfig();\n\t\tthis.notifications = [];\n\n\t\t// Connects this component up to the action queue, then handle incoming actions\n\t\tthis.queueServiceSubscription = this.queueService.actionStream.subscribe( ( action: NotifierAction ) => {\n\t\t\tthis.handleAction( action ).then( () => {\n\t\t\t\tthis.queueService.continue();\n\t\t\t} );\n\t\t} );\n\n\t}\n\n\t/**\n\t * Component destroyment lifecycle hook, cleans up the observable subsciption\n\t */\n\tpublic ngOnDestroy(): void {\n\t\tif ( this.queueServiceSubscription ) {\n\t\t\tthis.queueServiceSubscription.unsubscribe();\n\t\t}\n\t}\n\n\t/**\n\t * Notification identifier, used as the ngFor trackby function\n\t *\n\t * @param   index        Index\n\t * @param   notification Notifier notification\n\t * @returns Notification ID as the unique identnfier\n\t */\n\tpublic identifyNotification( index: number, notification: NotifierNotification ): string {\n\t\treturn notification.id;\n\t}\n\n\t/**\n\t * Event handler, handles clicks on notification dismiss buttons\n\t *\n\t * @param notificationId ID of the notification to dismiss\n\t */\n\tpublic onNotificationDismiss( notificationId: string ): void {\n\t\tthis.queueService.push( {\n\t\t\tpayload: notificationId,\n\t\t\ttype: 'HIDE'\n\t\t} );\n\t}\n\n\t/**\n\t * Event handler, handles notification ready events\n\t *\n\t * @param notificationComponent Notification component reference\n\t */\n\tpublic onNotificationReady( notificationComponent: NotifierNotificationComponent ): void {\n\t\tlet currentNotification: NotifierNotification = this.notifications[ this.notifications.length - 1 ]; // Get the latest notification\n\t\tcurrentNotification.component = notificationComponent; // Save the new omponent reference\n\t\tthis.continueHandleShowAction( currentNotification ); // Continue with handling the show action\n\t}\n\n\t/**\n\t * Handle incoming actions by mapping action types to methods, and then running them\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n\tprivate handleAction( action: NotifierAction ): Promise<undefined> {\n\t\tswitch ( action.type ) { // TODO: Maybe a map (actionType -> class method) is a cleaner solution here?\n\t\t\tcase 'SHOW':\n\t\t\t\treturn this.handleShowAction( action );\n\t\t\tcase 'HIDE':\n\t\t\t\treturn this.handleHideAction( action );\n\t\t\tcase 'HIDE_OLDEST':\n\t\t\t\treturn this.handleHideOldestAction( action );\n\t\t\tcase 'HIDE_NEWEST':\n\t\t\t\treturn this.handleHideNewestAction( action );\n\t\t\tcase 'HIDE_ALL':\n\t\t\t\treturn this.handleHideAllAction( action );\n\t\t\tdefault:\n\t\t\t\treturn new Promise<undefined>( ( resolve: () => void, reject: () => void ) => {\n\t\t\t\t\tresolve(); // Ignore unknown action types\n\t\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Show a new notification\n\t *\n\t * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n\tprivate handleShowAction( action: NotifierAction ): Promise<undefined> {\n\t\treturn new Promise<undefined>( ( resolve: () => void, reject: () => void ) => {\n\t\t\tthis.tempPromiseResolver = resolve; // Save the promise resolve function so that it can be called later on by another method\n\t\t\tthis.addNotificationToList( new NotifierNotification( action.payload ) );\n\t\t} );\n\t}\n\n\t/**\n\t * Continue to show a new notification (after the notification components is initialized / created / rendered).\n\t *\n\t * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n\t * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n\t * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n\t * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n\t *\n\t * @param notification New notification to show\n\t */\n\tprivate continueHandleShowAction( notification: NotifierNotification ): void {\n\n\t\t// First (which means only one) notification in the list?\n\t\tconst numberOfNotifications: number = this.notifications.length;\n\t\tif ( numberOfNotifications === 1 ) {\n\t\t\tnotification.component.show().then( this.tempPromiseResolver ); // Done\n\t\t} else {\n\n\t\t\tconst implicitStackingLimit: number = 2;\n\n\t\t\t// Stacking enabled? (stacking value below 2 means stacking is disabled)\n\t\t\tif ( this.config.behaviour.stacking === false || this.config.behaviour.stacking < implicitStackingLimit ) {\n\t\t\t\tthis.notifications[ 0 ].component.hide().then( () => {\n\t\t\t\t\tthis.removeNotificationFromList( this.notifications[ 0 ] );\n\t\t\t\t\tnotification.component.show().then( this.tempPromiseResolver ); // Done\n\t\t\t\t} );\n\t\t\t} else {\n\n\t\t\t\tconst stepPromises: Array<Promise<undefined>> = [];\n\n\t\t\t\t// Are there now too many notifications?\n\t\t\t\tif ( numberOfNotifications > this.config.behaviour.stacking ) {\n\n\t\t\t\t\tconst oldNotifications: Array<NotifierNotification> = this.notifications.slice( 1, numberOfNotifications - 1 );\n\n\t\t\t\t\t// Are animations enabled?\n\t\t\t\t\tif ( this.config.animations.enabled ) {\n\n\t\t\t\t\t\t// Is animation overlap enabled?\n\t\t\t\t\t\tif ( this.config.animations.overlap !== false && this.config.animations.overlap > 0 ) {\n\t\t\t\t\t\t\tstepPromises.push( this.notifications[ 0 ].component.hide() );\n\t\t\t\t\t\t\tsetTimeout( () => {\n\t\t\t\t\t\t\t\tstepPromises.push( this.shiftNotifications( oldNotifications, notification.component.getHeight(), true ) );\n\t\t\t\t\t\t\t}, this.config.animations.hide.speed - this.config.animations.overlap );\n\t\t\t\t\t\t\tsetTimeout( () => {\n\t\t\t\t\t\t\t\tstepPromises.push( notification.component.show() );\n\t\t\t\t\t\t\t}, this.config.animations.hide.speed + this.config.animations.shift.speed - this.config.animations.overlap );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstepPromises.push( new Promise<undefined>( ( resolve: () => void, reject: () => void ) => {\n\t\t\t\t\t\t\t\tthis.notifications[ 0 ].component.hide().then( () => {\n\t\t\t\t\t\t\t\t\tthis.shiftNotifications( oldNotifications, notification.component.getHeight(), true ).then( () => {\n\t\t\t\t\t\t\t\t\t\tnotification.component.show().then( resolve );\n\t\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t} ) );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstepPromises.push( this.notifications[ 0 ].component.hide() );\n\t\t\t\t\t\tstepPromises.push( this.shiftNotifications( oldNotifications, notification.component.getHeight(), true ) );\n\t\t\t\t\t\tstepPromises.push( notification.component.show() );\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst oldNotifications: Array<NotifierNotification> = this.notifications.slice( 0, numberOfNotifications - 1 );\n\n\t\t\t\t\t// Are animations enabled?\n\t\t\t\t\tif ( this.config.animations.enabled ) {\n\n\t\t\t\t\t\t// Is animation overlap enabled?\n\t\t\t\t\t\tif ( this.config.animations.overlap !== false && this.config.animations.overlap > 0 ) {\n\t\t\t\t\t\t\tstepPromises.push( this.shiftNotifications( oldNotifications, notification.component.getHeight(), true ) );\n\t\t\t\t\t\t\tsetTimeout( () => {\n\t\t\t\t\t\t\t\tstepPromises.push( notification.component.show() );\n\t\t\t\t\t\t\t}, this.config.animations.shift.speed - this.config.animations.overlap );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstepPromises.push( new Promise<undefined>( ( resolve: () => void, reject: () => void ) => {\n\t\t\t\t\t\t\t\tthis.shiftNotifications( oldNotifications, notification.component.getHeight(), true ).then( () => {\n\t\t\t\t\t\t\t\t\tnotification.component.show().then( resolve );\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t} ) );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstepPromises.push( this.shiftNotifications( oldNotifications, notification.component.getHeight(), true ) );\n\t\t\t\t\t\tstepPromises.push( notification.component.show() );\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tPromise.all( stepPromises ).then( () => {\n\t\t\t\t\tif ( numberOfNotifications > this.config.behaviour.stacking ) {\n\t\t\t\t\t\tthis.removeNotificationFromList( this.notifications[ 0 ] );\n\t\t\t\t\t}\n\t\t\t\t\tthis.tempPromiseResolver();\n\t\t\t\t} ); // Done\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Hide an existing notification\n\t *\n\t * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n\t * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n\t * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n\t *\n\t * @param   action Action object, payload contains the notification ID\n\t * @returns Promise, resolved when done\n\t */\n\tprivate handleHideAction( action: NotifierAction ): Promise<undefined> {\n\t\treturn new Promise<undefined>( ( resolve: () => void, reject: () => void ) => {\n\n\t\t\tconst stepPromises: Array<Promise<undefined>> = [];\n\n\t\t\t// Does the notification exist / are there even any notifications? (let's prevent accidential errors)\n\t\t\tconst notification: NotifierNotification | undefined = this.findNotificationById( action.payload );\n\t\t\tif ( notification === undefined ) {\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get older notifications\n\t\t\tconst notificationIndex: number | undefined = this.findNotificationIndexById( action.payload );\n\t\t\tif ( notificationIndex === undefined ) {\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst oldNotifications: Array<NotifierNotification> = this.notifications.slice( 0, notificationIndex );\n\n\t\t\t// Do older notifications exist, and thus do we need to shift other notifications as a consequence?\n\t\t\tif ( oldNotifications.length > 0 ) {\n\n\t\t\t\t// Are animations enabled?\n\t\t\t\tif ( this.config.animations.enabled && this.config.animations.hide.speed > 0 ) {\n\n\t\t\t\t\t// Is animation overlap enabled?\n\t\t\t\t\tif ( this.config.animations.overlap !== false && this.config.animations.overlap > 0 ) {\n\t\t\t\t\t\tstepPromises.push( notification.component.hide() );\n\t\t\t\t\t\tsetTimeout( () => {\n\t\t\t\t\t\t\tstepPromises.push( this.shiftNotifications( oldNotifications, notification.component.getHeight(), false ) );\n\t\t\t\t\t\t}, this.config.animations.hide.speed - this.config.animations.overlap );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnotification.component.hide().then( () => {\n\t\t\t\t\t\t\tstepPromises.push( this.shiftNotifications( oldNotifications, notification.component.getHeight(), false ) );\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstepPromises.push( notification.component.hide() );\n\t\t\t\t\tstepPromises.push( this.shiftNotifications( oldNotifications, notification.component.getHeight(), false ) );\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstepPromises.push( notification.component.hide() );\n\n\t\t\t}\n\n\t\t\t// Wait until both hiding and shifting is done, then remove the notification from the list\n\t\t\tPromise.all( stepPromises ).then( () => {\n\t\t\t\tthis.removeNotificationFromList( notification );\n\t\t\t\tresolve(); // Done\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Hide the oldest notification (bridge to handleHideAction)\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n\tprivate handleHideOldestAction( action: NotifierAction ): Promise<undefined> {\n\n\t\t// Are there any notifications? (prevent accidential errors)\n\t\tif ( this.notifications.length === 0 ) {\n\t\t\treturn new Promise<undefined>( ( resolve: () => void, reject: () => void ) => {\n\t\t\t\tresolve();\n\t\t\t} ); // Done\n\t\t} else {\n\t\t\taction.payload = this.notifications[ 0 ].id;\n\t\t\treturn this.handleHideAction( action );\n\t\t}\n\n\t}\n\n\t/**\n\t * Hide the newest notification (bridge to handleHideAction)\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n\tprivate handleHideNewestAction( action: NotifierAction ): Promise<undefined> {\n\n\t\t// Are there any notifications? (prevent accidential errors)\n\t\tif ( this.notifications.length === 0 ) {\n\t\t\treturn new Promise<undefined>( ( resolve: () => void, reject: () => void ) => {\n\t\t\t\tresolve();\n\t\t\t} ); // Done\n\t\t} else {\n\t\t\taction.payload = this.notifications[ this.notifications.length - 1 ].id;\n\t\t\treturn this.handleHideAction( action );\n\t\t}\n\n\t}\n\n\t/**\n\t * Hide all notifications at once\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n\tprivate handleHideAllAction( action: NotifierAction ): Promise<undefined> {\n\t\treturn new Promise<undefined>( ( resolve: () => void, reject: () => void ) => {\n\n\t\t\t// Are there any notifications? (prevent accidential errors)\n\t\t\tconst numberOfNotifications: number = this.notifications.length;\n\t\t\tif ( numberOfNotifications === 0 ) {\n\t\t\t\tresolve(); // Done\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Are animations enabled?\n\t\t\tif ( this.config.animations.enabled && this.config.animations.hide.speed > 0 && this.config.animations.hide.offset !== false &&\n\t\t\t\tthis.config.animations.hide.offset > 0 ) {\n\n\t\t\t\tfor ( let i: number = numberOfNotifications - 1; i >= 0; i-- ) {\n\t\t\t\t\tconst animationOffset: number = this.config.position.vertical.position === 'top' ? numberOfNotifications - 1 : i;\n\t\t\t\t\tsetTimeout( () => {\n\t\t\t\t\t\tthis.notifications[ i ].component.hide().then( () => {\n\n\t\t\t\t\t\t\t// Are we done here, was this the last notification to be hidden?\n\t\t\t\t\t\t\tif ( ( this.config.position.vertical.position === 'top' && i === 0 ) ||\n\t\t\t\t\t\t\t\t( this.config.position.vertical.position === 'bottom' && i === numberOfNotifications - 1 ) ) {\n\t\t\t\t\t\t\t\tthis.removeAllNotificationsFromList();\n\t\t\t\t\t\t\t\tresolve(); // Done\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\t\t\t\t\t}, this.config.animations.hide.offset * animationOffset );\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tlet stepPromises: Array<Promise<undefined>> = [];\n\t\t\t\tfor ( let i: number = numberOfNotifications - 1; i >= 0; i-- ) {\n\t\t\t\t\tstepPromises.push( this.notifications[ i ].component.hide() );\n\t\t\t\t}\n\t\t\t\tPromise.all( stepPromises ).then( () => {\n\t\t\t\t\tthis.removeAllNotificationsFromList();\n\t\t\t\t\tresolve(); // Done\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\t}\n\n\t/**\n\t * Shift multiple notifications at once\n\t *\n\t * @param   notifications List containing the notifications to be shifted\n\t * @param   distance      Distance to shift (in px)\n\t * @param   toMakePlace   Flag, defining in which direciton to shift\n\t * @returns Promise, resolved when done\n\t */\n\tprivate shiftNotifications( notifications: Array<NotifierNotification>, distance: number, toMakePlace: boolean ): Promise<undefined> {\n\t\treturn new Promise<undefined>( ( resolve: () => void, reject: () => void ) => {\n\n\t\t\t// Are there any notifications to shift?\n\t\t\tif ( notifications.length === 0 ) {\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet notificationPromises: Array<Promise<undefined>> = [];\n\t\t\tfor ( let i: number = notifications.length - 1; i >= 0; i-- ) {\n\t\t\t\tnotificationPromises.push( notifications[ i ].component.shift( distance, toMakePlace ) );\n\t\t\t}\n\t\t\tPromise.all( notificationPromises ).then( resolve ); // Done\n\n\t\t} );\n\t}\n\n\t/**\n\t * Add a new notification to the list of notifications (triggers change detection)\n\t *\n\t * @param notification Notification to add to the list of notifications\n\t */\n\tprivate addNotificationToList( notification: NotifierNotification ): void {\n\t\tthis.notifications.push( notification );\n\t\tthis.changeDetector.markForCheck(); // Run change detection because the notification list changed\n\t}\n\n\t/**\n\t * Remove an existing notification from the list of notifications (triggers change detection)\n\t *\n\t * @param notification Notification to be removed from the list of notifications\n\t */\n\tprivate removeNotificationFromList( notification: NotifierNotification ): void {\n\t\tthis.notifications =\n\t\t\tthis.notifications.filter( ( item: NotifierNotification ) => item.component !== notification.component );\n\t\tthis.changeDetector.markForCheck(); // Run change detection because the notification list changed\n\t}\n\n\t/**\n\t * Remove all notifications from the list (triggers change detection)\n\t */\n\tprivate removeAllNotificationsFromList(): void {\n\t\tthis.notifications = [];\n\t\tthis.changeDetector.markForCheck(); // Run change detection because the notification list changed\n\t}\n\n\t/**\n\t * Helper: Find a notification in the notification list by a given notification ID\n\t *\n\t * @param   notificationId Notification ID, used for finding notification\n\t * @returns Notification, undefined if not found\n\t */\n\tprivate findNotificationById( notificationId: string ): NotifierNotification | undefined {\n\t\treturn this.notifications.find( ( currentNotification: NotifierNotification ) => currentNotification.id === notificationId );\n\t}\n\n\t/**\n\t * Helper: Find a notification's index by a given notification ID\n\t *\n\t * @param   notificationId Notification ID, used for finding a notification's index\n\t * @returns Notification index, undefined if not found\n\t */\n\tprivate findNotificationIndexById( notificationId: string ): number | undefined {\n\t\tconst notificationIndex: number =\n\t\t\tthis.notifications.findIndex( ( currentNotification: NotifierNotification ) => currentNotification.id === notificationId );\n\t\treturn ( notificationIndex !== -1 ? notificationIndex : undefined );\n\t}\n\n}\n","import { CommonModule } from '@angular/common';\nimport { ModuleWithProviders, NgModule } from '@angular/core';\n\nimport { NotifierContainerComponent } from './components/notifier-container.component';\nimport { NotifierNotificationComponent } from './components/notifier-notification.component';\nimport { NotifierConfig, NotifierOptions } from './models/notifier-config.model';\nimport { NotifierAnimationService } from './services/notifier-animation.service';\nimport { NotifierQueueService } from './services/notifier-queue.service';\nimport { NotifierService } from './services/notifier.service';\nimport { NotifierConfigToken, NotifierOptionsToken } from './notifier.tokens';\n\n/**\n * Factory for a notifier configuration with custom options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @param   options - Custom notifier options\n * @returns - Notifier configuration as result\n */\nexport function notifierCustomConfigFactory( options: NotifierOptions ): NotifierConfig {\n\treturn new NotifierConfig( options );\n}\n\n/**\n * Factory for a notifier configuration with default options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @returns - Notifier configuration as result\n */\nexport function notifierDefaultConfigFactory(): NotifierConfig {\n\treturn new NotifierConfig( {} );\n}\n\n/**\n * Notifier module\n */\n@NgModule( {\n\tdeclarations: [\n\t\tNotifierContainerComponent,\n\t\tNotifierNotificationComponent\n\t],\n\texports: [\n\t\tNotifierContainerComponent\n\t],\n\timports: [\n\t\tCommonModule\n\t],\n\tproviders: [\n\t\tNotifierAnimationService,\n\t\tNotifierService,\n\t\tNotifierQueueService,\n\n\t\t// Provide the default notifier configuration if just the module is imported\n\t\t{\n\t\t\tprovide: NotifierConfigToken,\n\t\t\tuseFactory: notifierDefaultConfigFactory\n\t\t}\n\n\t]\n} )\nexport class NotifierModule {\n\n\t/**\n\t * Setup the notifier module with custom providers, in this case with a custom configuration based on the givne options\n\t *\n\t * @param   [options={}] - Custom notifier options\n\t * @returns - Notifier module with custom providers\n\t */\n\tpublic static withConfig( options: NotifierOptions = {} ): ModuleWithProviders<NotifierModule> {\n\t\treturn {\n\t\t\tngModule: NotifierModule,\n\t\t\tproviders: [\n\n\t\t\t\t// Provide the options itself upfront (as we need to inject them as dependencies -- see below)\n\t\t\t\t{\n\t\t\t\t\tprovide: NotifierOptionsToken,\n\t\t\t\t\tuseValue: options\n\t\t\t\t},\n\n\t\t\t\t// Provide a custom notifier configuration, based on the given notifier options\n\t\t\t\t{\n\t\t\t\t\tdeps: [\n\t\t\t\t\t\tNotifierOptionsToken\n\t\t\t\t\t],\n\t\t\t\t\tprovide: NotifierConfigToken,\n\t\t\t\t\tuseFactory: notifierCustomConfigFactory\n\t\t\t\t}\n\n\t\t\t]\n\t\t};\n\t}\n\n}\n"]}